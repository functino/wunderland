// Generated by CoffeeScript 1.3.3
(function() {
  var __slice = [].slice;

  module.exports = function() {
    var build, bundle, compileTemplates, compressor, config, fs, print, spawn, spawnAndLog, style;
    fs = require("fs");
    print = require('util').print;
    spawn = require('child_process').spawn;
    compressor = require('node-minify');
    spawnAndLog = function(name, params) {
      var spawned;
      spawned = spawn(name, params);
      spawned.stdout.on('data', function(data) {
        return print(data.toString());
      });
      spawned.stderr.on("data", function(data) {
        return process.stderr.write(data.toString());
      });
      return spawned;
    };
    config = JSON.parse(fs.readFileSync("config/application.json"));
    task("create", "", function() {
      var create;
      create = require("./create");
      return create({
        appName: "testname"
      });
    });
    bundle = function() {
      var code, component, componentsConfig, conf, file, _i, _len, _ref;
      code = compileTemplates();
      componentsConfig = JSON.parse(fs.readFileSync("./component.json"));
      for (component in componentsConfig.dependencies) {
        conf = JSON.parse(fs.readFileSync("./components/" + component + "/component.json"));
        code += fs.readFileSync("./components/" + component + "/" + conf.main);
      }
      _ref = config.bundle;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        file = _ref[_i];
        code += ";\n" + fs.readFileSync("src/" + file);
      }
      fs.writeFileSync('public/application.js', code);
      return console.log("bundled js");
    };
    build = function(watch) {
      var coffee, folder, options, _i, _len, _ref, _results;
      console.log("Watching .coffee files");
      _ref = ['./src'];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        folder = _ref[_i];
        options = ['-c', '-o', folder, folder];
        if (watch) {
          options.unshift('-w');
        }
        coffee = spawnAndLog('coffee', options);
        _results.push(coffee.stdout.on('data', function(data) {
          return bundle();
        }));
      }
      return _results;
    };
    style = function(watch) {
      var options;
      console.log("Watching stylesheets");
      options = ["compile"];
      if (watch) {
        options = ['watch'];
      }
      return spawnAndLog('compass', options);
    };
    compileTemplates = function() {
      var code, content, eco, extension, file, filename, files, path, templateSource, templates, _i, _j, _len, _ref;
      path = "./src/templates";
      files = fs.readdirSync(path);
      eco = require("eco");
      templates = [];
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        _ref = file.split("."), filename = 2 <= _ref.length ? __slice.call(_ref, 0, _j = _ref.length - 1) : (_j = 0, []), extension = _ref[_j++];
        if (extension === "html") {
          console.log("compiling " + filename);
          content = fs.readFileSync(path + "/" + file);
          templateSource = eco.precompile(content.toString());
          templates.push("JST." + filename + " = " + templateSource);
        }
      }
      code = "JST = {};" + templates.join(";") + ";";
      console.log("compiled templates");
      return code;
    };
    task('build', 'Build', function() {
      build(false);
      return style(false);
    });
    task('watch', "build and watch", function() {
      var watch;
      build(true);
      style(true);
      watch = require('watch');
      return watch.watchTree("./src/templates", function() {
        console.log("detected template change");
        return bundle();
      });
    });
    task("bundle", "bundles the javascript files to one file", function() {
      return bundle();
    });
    task("minify", "minify js and css", function() {
      new compressor.minify({
        type: 'yui',
        fileIn: './public/style.css',
        fileOut: './public/style.css',
        callback: function(err) {
          return console.log(err);
        }
      });
      return new compressor.minify({
        type: 'yui',
        fileIn: './public/application.js',
        fileOut: './public/application.js',
        callback: function(err) {
          return console.log(err);
        }
      });
    });
    option('-w', '--watch', 'should the server task start the watch task?');
    task("server", "Start a development server", function(options) {
      var node;
      if (options.watch) {
        invoke("watch");
      }
      process.env.PORT = config.port;
      return node = spawnAndLog('node', ['web.js']);
    });
    task("test-server", "Start a test server", function(options) {
      return spawnAndLog('buster', ['server']);
    });
    task("test-static", "Start a test server", function(options) {
      return spawnAndLog('buster', ['static']);
    });
    task("test", "run the tests", function() {
      return spawnAndLog('buster', ['test', '--config', 'test/config.js']);
    });
    return task("manifest", "manifest", function() {
      var execFile, files;
      files = [];
      execFile = require('child_process').execFile;
      return execFile('find', ['./public'], function(err, stdout, stderr) {
        var file, _i, _len, _ref;
        _ref = stdout.toString().replace("/public/", "").split("\n");
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          file = _ref[_i];
          file = file.replace("./public/", "");
          if (file[0] !== ".") {
            files.push(file);
          }
        }
        return console.log(files.join("\n"));
      });
    });
  };

}).call(this);
